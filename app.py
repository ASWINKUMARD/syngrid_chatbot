# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q31xPIuketdM7UwUIXtJh1XpQ2eZOLyT
"""

!pip install fastapi uvicorn python-dotenv beautifulsoup4 requests langchain langchain-community langchain-huggingface chromadb sentence-transformers pydantic typing-extensions certifi

import os
import json
import requests
from dotenv import load_dotenv
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import Chroma
from langchain_huggingface import HuggingFaceEmbeddings
import re
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse, JSONResponse
from pydantic import BaseModel, field_validator
import sqlite3
from contextlib import contextmanager, asynccontextmanager


load_dotenv()

OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
if not OPENROUTER_API_KEY:
    raise Exception("OPENROUTER_API_KEY is missing! Add it in Render environment vars.")

OPENROUTER_API_BASE = "https://openrouter.ai/api/v1/chat/completions"
MODELS = ["kwaipilot/kat-coder-pro:free"]

retriever = None
cache = {}
status = {"ready": False, "message": "Initializing..."}

DB_NAME = "users.db"

@contextmanager
def get_db():
    conn = sqlite3.connect(DB_NAME)
    conn.row_factory = sqlite3.Row
    try:
        yield conn
    finally:
        conn.close()

def init_database():
    with get_db() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT NOT NULL,
                phone TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()
    print("âœ“ Database initialized")


class QuestionRequest(BaseModel):
    question: str
    session_id: str = "default"

class UserInfoRequest(BaseModel):
    name: str
    email: str
    phone: str
    session_id: str = "default"

    @field_validator("email")
    def validate_email(cls, v):
        pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
        if not re.match(pattern, v):
            raise ValueError("Invalid email address")
        return v

    @field_validator("phone")
    def validate_phone(cls, v):
        pattern = r"^\+?[0-9\s\-\(\)]{10,}$"
        if not re.match(pattern, v):
            raise ValueError("Invalid phone number")
        return v

def scrape_website(base_url, max_pages=25):
    visited = set()
    all_content = []

    def crawl(url, depth=0):
        if len(visited) >= max_pages or depth > 3: return
        if url in visited: return

        try:
            resp = requests.get(url, headers={"User-Agent": "Mozilla/5.0"}, timeout=10)
            if resp.status_code != 200: return

            visited.add(url)
            print(f"Scraped: {url}")

            soup = BeautifulSoup(resp.text, "html.parser")
            for tag in soup(["script", "style", "nav", "footer"]): tag.decompose()

            text = soup.get_text(separator="\n", strip=True)
            clean = "\n".join([x for x in text.split("\n") if x.strip()])

            if len(clean) > 100:
                all_content.append(clean)

            base_domain = urlparse(base_url).netloc
            for link in soup.find_all("a", href=True):
                next_url = urljoin(url, link["href"])
                if urlparse(next_url).netloc == base_domain:
                    crawl(next_url, depth + 1)

        except:
            pass

    crawl(base_url)
    return "\n\n".join(all_content)


def initialize_rag(url="https://syngrid.com/"):
    global retriever, status
    try:
        status["message"] = "Scraping website..."
        content = scrape_website(url)

        if len(content) < 500:
            status["message"] = "Failed: Not enough content scraped"
            return

        status["message"] = "Splitting content..."
        splitter = RecursiveCharacterTextSplitter(chunk_size=1800, chunk_overlap=150)
        chunks = splitter.split_text(content)

        status["message"] = "Loading embeddings..."
        embeddings = HuggingFaceEmbeddings(
            model_name="all-MiniLM-L6-v2",
            model_kwargs={"device": "cpu"},
            encode_kwargs={"normalize_embeddings": True}
        )

        status["message"] = "Building vector DB..."
        vectorstore = Chroma.from_texts(
            chunks,
            embedding=embeddings,
            persist_directory="./chroma_db"
        )

        retriever = vectorstore.as_retriever(search_kwargs={"k": 4})
        status["ready"] = True
        status["message"] = "Ready!"
        print("RAG Ready")

    except Exception as e:
        status["message"] = str(e)
        print("ERROR:", e)


def call_llm(question, context):
    prompt = f"""Use ONLY the following context to answer in 1-3 sentences.

Context:
{context[:3000]}

Question: {question}

Answer:"""

    headers = {"Authorization": f"Bearer {OPENROUTER_API_KEY}", "Content-Type": "application/json"}

    payload = {
        "model": MODELS[0],
        "messages": [
            {"role": "system", "content": "Answer using ONLY context."},
            {"role": "user", "content": prompt},
        ],
        "temperature": 0.2,
        "max_tokens": 120
    }

    r = requests.post(OPENROUTER_API_BASE, headers=headers, json=payload)
    if r.status_code == 200:
        return r.json()["choices"][0]["message"]["content"].strip()

    return "Error contacting LLM."

session_data = {}

@asynccontextmanager
async def lifespan(app):
    init_database()
    initialize_rag("https://syngrid.com/")
    yield

app = FastAPI(title="Syngrid AI", lifespan=lifespan)

@app.get("/api/status")
def api_status():
    return status


@app.post("/api/ask")
def ask(req: QuestionRequest):
    if not status["ready"]:
        raise HTTPException(503, status["message"])

    if req.session_id not in session_data:
        session_data[req.session_id] = {"count": 0, "info": False}

    if session_data[req.session_id]["count"] >= 3 and not session_data[req.session_id]["info"]:
        return {"answer": "Please submit your information to continue.", "needs_user_info": True}

    q = req.question.lower().strip()

    if q in cache:
        answer = "ðŸ’¾ (cached) " + cache[q]
    else:
        docs = retriever.invoke(req.question)
        if docs:
            context = "\n\n".join([d.page_content for d in docs])
            answer = call_llm(req.question, context)
            cache[q] = answer
        else:
            answer = "No relevant data found."

    session_data[req.session_id]["count"] += 1
    return {"answer": answer, "needs_user_info": False}


@app.post("/api/submit-info")
def submit_info(req: UserInfoRequest):
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            cursor.execute("INSERT INTO users (name,email,phone) VALUES (?,?,?)",
                           (req.name, req.email, req.phone))
            conn.commit()

        session_data[req.session_id]["info"] = True
        return {"success": True, "message": "Information saved successfully!"}

    except Exception as e:
        raise HTTPException(500, str(e))


@app.get("/api/users")
def list_users():
    with get_db() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users ORDER BY created_at DESC")
        users = [dict(row) for row in cursor.fetchall()]
    return users

@app.get("/", response_class=HTMLResponse)
def home_page():
    return """
<!DOCTYPE html>
<html>
<head>
<title>Syngrid AI</title>
<style>
body {font-family:Arial; background:#eef; padding:30px;}
.chat {max-width:800px; margin:auto; background:white; padding:20px; border-radius:15px;}
.box {padding:10px; margin:8px; border-radius:6px;}
.user {background:#69f; color:white; text-align:right;}
.bot {background:#ddd;}
</style>
</head>
<body>
<div class='chat'>
<h2>ðŸ¤– Syngrid AI Assistant</h2>
<div id='messages'></div><br>

<input id='q' style='padding:10px;width:70%;'>
<button onclick='ask()' style='padding:10px;'>Send</button>

<div id='form' style='display:none;margin-top:20px;border:1px solid #aaa;padding:15px;'>
<h3>Enter your details</h3>
<input id='name' placeholder='Name'><br><br>
<input id='email' placeholder='Email'><br><br>
<input id='phone' placeholder='Phone'><br><br>
<button onclick='submitInfo()'>Submit</button>
</div>
</div>

<script>
const sid="sess"+Date.now();

function msg(t,c){
 document.getElementById("messages").innerHTML+=`<div class='box ${c}'>${t}</div>`;
}

async function ask(){
 let q=document.getElementById("q").value;
 if(!q)return;
 msg(q,"user");
 document.getElementById("q").value="";

 let r=await fetch("/api/ask",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({question:q,session_id:sid})});
 let d=await r.json();

 if(d.needs_user_info){ document.getElementById("form").style.display="block"; }

 msg(d.answer,"bot");
}

async function submitInfo(){
 let name=document.getElementById("name").value;
 let email=document.getElementById("email").value;
 let phone=document.getElementById("phone").value;

 let emailRe=/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;
 if(!emailRe.test(email)){ alert("Invalid email"); return; }

 await fetch("/api/submit-info",{method:"POST",headers:{"Content-Type":"application/json"},
 body:JSON.stringify({name,email,phone,session_id:sid})});

 document.getElementById("form").style.display="none";
 msg("âœ” Thank you! Info saved.","bot");
}
</script>

</body>
</html>
"""


# ==========================================
# RUN UVICORN (RENDER USES GUNICORN)
# ==========================================
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=int(os.getenv("PORT", 8000)), reload=False)

