# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q31xPIuketdM7UwUIXtJh1XpQ2eZOLyT
"""

import os
import json
import requests
from dotenv import load_dotenv
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse

from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import Chroma
from langchain_huggingface import HuggingFaceEmbeddings

import re
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse, JSONResponse
from pydantic import BaseModel, validator
import sqlite3
from contextlib import contextmanager, asynccontextmanager

# ============================
# ENV VARS
# ============================
load_dotenv()

OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
if not OPENROUTER_API_KEY:
    raise Exception("OPENROUTER_API_KEY is missing in Render environment variables.")

OPENROUTER_API_BASE = "https://openrouter.ai/api/v1/chat/completions"
MODELS = ["kwaipilot/kat-coder-pro:free"]

retriever = None
cache = {}
status = {"ready": False, "message": "Initializing..."}

# ============================
# SQLITE DB
# ============================
DB_NAME = "users.db"

@contextmanager
def get_db():
    conn = sqlite3.connect(DB_NAME)
    conn.row_factory = sqlite3.Row
    try:
        yield conn
    finally:
        conn.close()


def init_database():
    with get_db() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT NOT NULL,
                phone TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()
    print("âœ“ Database initialized")


# ============================
# MODELS
# ============================
class QuestionRequest(BaseModel):
    question: str
    session_id: str = "default"


class UserInfoRequest(BaseModel):
    name: str
    email: str
    phone: str
    session_id: str = "default"

    @validator("email")
    def validate_email(cls, v):
        if not re.match(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", v):
            raise ValueError("Invalid email format")
        return v

    @validator("phone")
    def validate_phone(cls, v):
        if not re.match(r"^\+?[0-9\s\-()]{10,}$", v):
            raise ValueError("Invalid phone number")
        return v


# ============================
# SCRAPER (LIGHTWEIGHT)
# ============================
def scrape_website(base_url, max_pages=8):  # reduce to fit memory
    visited = set()
    all_content = []

    def crawl(url, depth=0):
        if len(visited) >= max_pages or depth > 2:
            return
        if url in visited:
            return

        try:
            resp = requests.get(url, headers={"User-Agent": "Mozilla/5.0"}, timeout=10)
            if resp.status_code != 200:
                return

            visited.add(url)
            print("Scraped:", url)

            soup = BeautifulSoup(resp.text, "html.parser")
            for tag in soup(["script", "style", "nav", "footer"]):
                tag.decompose()

            text = soup.get_text(separator="\n", strip=True)
            cleaned = "\n".join([x for x in text.split("\n") if x.strip()])

            if len(cleaned) > 80:
                all_content.append(cleaned)

            base_domain = urlparse(base_url).netloc

            for link in soup.find_all("a", href=True):
                next_url = urljoin(url, link["href"])
                if urlparse(next_url).netloc == base_domain:
                    crawl(next_url, depth + 1)
        except:
            pass

    crawl(base_url)
    return "\n\n".join(all_content)


# ============================
# RAG INITIALIZER (LOW MEMORY)
# ============================
def initialize_rag(url="https://syngrid.com/"):
    global retriever, status
    try:
        status["message"] = "Scraping website..."
        content = scrape_website(url)

        if len(content) < 200:
            status["message"] = "Not enough content scraped."
            return

        # Lighter splitter
        splitter = RecursiveCharacterTextSplitter(
            chunk_size=700,   # reduced for memory
            chunk_overlap=70
        )
        chunks = splitter.split_text(content)

        # LIGHT EMBEDDING MODEL (30MB)
        embeddings = HuggingFaceEmbeddings(
            model_name="sentence-transformers/paraphrase-MiniLM-L3-v2",
            model_kwargs={"device": "cpu"},
            encode_kwargs={"normalize_embeddings": True}
        )

        # NO PERSISTENCE â†’ MUCH LESS MEMORY
        vectorstore = Chroma.from_texts(
            chunks,
            embedding=embeddings
        )

        retriever = vectorstore.as_retriever(search_kwargs={"k": 3})

        status["ready"] = True
        status["message"] = "Ready!"
        print("RAG Ready!")

    except Exception as e:
        status["message"] = str(e)
        print("ERROR:", e)


# ============================
# LLM CALL
# ============================
def call_llm(question, context):
    prompt = f"""
Use ONLY the following context to answer:

Context:
{context[:3000]}

Question: {question}

Answer:
"""

    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": MODELS[0],
        "messages": [
            {"role": "system", "content": "Answer using ONLY the context."},
            {"role": "user", "content": prompt}
        ],
        "temperature": 0.2,
        "max_tokens": 100
    }

    res = requests.post(OPENROUTER_API_BASE, headers=headers, json=payload)
    if res.status_code == 200:
        return res.json()["choices"][0]["message"]["content"].strip()

    return "LLM error."


# ============================
# FASTAPI APP
# ============================
session_data = {}

@asynccontextmanager
async def lifespan(app):
    init_database()
    initialize_rag("https://syngrid.com/")
    yield


app = FastAPI(title="Syngrid AI", lifespan=lifespan)


@app.get("/api/status")
def api_status():
    return status


@app.post("/api/ask")
def ask(req: QuestionRequest):

    if not status["ready"]:
        raise HTTPException(503, status["message"])

    if req.session_id not in session_data:
        session_data[req.session_id] = {"count": 0, "info": False}

    if session_data[req.session_id]["count"] >= 3 and not session_data[req.session_id]["info"]:
        return {"answer": "Please submit your information to continue.", "needs_user_info": True}

    q = req.question.lower().strip()

    if q in cache:
        answer = "(cached) " + cache[q]
    else:
        docs = retriever.invoke(req.question)
        if docs:
            context = "\n\n".join([d.page_content for d in docs])
            answer = call_llm(req.question, context)
            cache[q] = answer
        else:
            answer = "No matching information found."

    session_data[req.session_id]["count"] += 1
    return {"answer": answer, "needs_user_info": False}


@app.post("/api/submit-info")
def submit_info(req: UserInfoRequest):
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO users (name, email, phone) VALUES (?, ?, ?)",
                (req.name, req.email, req.phone)
            )
            conn.commit()

        session_data[req.session_id]["info"] = True
        return {"success": True, "message": "Information saved!"}

    except Exception as e:
        raise HTTPException(500, str(e))


@app.get("/api/users")
def list_users():
    with get_db() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users ORDER BY created_at DESC")
        return [dict(row) for row in cursor.fetchall()]


@app.get("/", response_class=HTMLResponse)
def home_page():
    return """
    <html><body style="font-family:Arial;padding:20px;">
    <h2>ðŸ¤– Syngrid AI Assistant</h2>
    <p>Chatbot is running successfully on Render Free Plan!</p>
    </body></html>
    """


if __name__ == "__main__":
    import uvicorn
    uvicorn.run("app:app", host="0.0.0.0", port=8000)